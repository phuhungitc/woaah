{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findMatchingElement = exports.isLoadable = exports.isRoutesDifferent = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactRouter = require(\"react-router\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar isRoutesDifferent = function isRoutesDifferent(current, next) {\n  var _next$location, _current$location;\n\n  return ((_next$location = next.location) === null || _next$location === void 0 ? void 0 : _next$location.pathname) !== ((_current$location = current.location) === null || _current$location === void 0 ? void 0 : _current$location.pathname);\n};\n\nexports.isRoutesDifferent = isRoutesDifferent;\n\nvar findMatchingRoute = function findMatchingRoute(location, routes) {\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (matchingElement) {};\n  var match; // We use React.Children.forEach instead of React.Children.toArray().find()\n  // here because toArray adds keys to all child elements and we do not want\n  // to trigger an unmount/remount for two <Route>s that render the same\n  // component at different URLs.\n\n  _react[\"default\"].Children.forEach(routes, function (child) {\n    if (match == null && /*#__PURE__*/_react[\"default\"].isValidElement(child)) {\n      var path = child.props.path || child.props.from;\n      match = (0, _reactRouter.matchPath)(location === null || location === void 0 ? void 0 : location.pathname, _objectSpread(_objectSpread({}, child.props), {}, {\n        path: path\n      }));\n      if (match) callback(child);\n    }\n  });\n\n  return match;\n};\n\nvar isLoadable = function isLoadable(location, routes) {\n  var isLoadable;\n  var match = findMatchingRoute(location, routes, function (matchingElement) {\n    isLoadable = matchingElement.props.loading;\n  });\n  return match ? isLoadable : false;\n};\n\nexports.isLoadable = isLoadable;\n\nvar findMatchingElement = function findMatchingElement(location, routes) {\n  var element;\n  var match = findMatchingRoute(location, routes, function (matchingElement) {\n    element = matchingElement;\n  });\n  return match ? /*#__PURE__*/_react[\"default\"].cloneElement(element, {\n    location: location,\n    computedMatch: match\n  }) : null;\n};\n\nexports.findMatchingElement = findMatchingElement;","map":{"version":3,"sources":["../src/utils.js"],"names":["isRoutesDifferent","current","findMatchingRoute","callback","React","match","path","child","location","isLoadable","matchingElement","findMatchingElement","element","computedMatch"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO,IAAMA,iBAAiB,GAAG,SAApBA,iBAAoB,CAAA,OAAA,EAAA,IAAA,EAAA;AAAA,MAAA,cAAA,EAAA,iBAAA;;AAAA,SAAmB,CAAA,CAAA,cAAA,GAAA,IAAI,CAAJ,QAAA,MAAA,IAAA,IAAA,cAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,cAAA,CAAA,QAAA,OAAA,CAAA,iBAAA,GAA4BC,OAAO,CAAnC,QAAA,MAAA,IAAA,IAAA,iBAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAA4BA,iBAAAA,CAA/C,QAAmB,CAAnB;AAA1B,CAAA;;;;AAEP,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAA,QAAA,EAAA,MAAA,EAA2D;AAAA,MAAxCC,QAAwC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA7B,UAAA,eAAA,EAAqB,CAAQ,CAAA;AACjF,MADiF,KACjF,CADiF,CAGjF;AACA;AACA;AACA;;AACAC,EAAAA,MAAAA,CAAAA,SAAAA,CAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAAA,MAAAA,EAA+B,UAAA,KAAA,EAAS;AACpC,QAAIC,KAAK,IAALA,IAAAA,IAAAA,aAAiBD,MAAAA,CAAAA,SAAAA,CAAAA,CAAAA,cAAAA,CAArB,KAAqBA,CAArB,EAAkD;AAC9C,UAAME,IAAI,GAAGC,KAAK,CAALA,KAAAA,CAAAA,IAAAA,IAAoBA,KAAK,CAALA,KAAAA,CAAjC,IAAA;AACAF,MAAAA,KAAK,GAAG,CAAA,GAAA,YAAA,CAAA,SAAA,EAAUG,QAAV,KAAA,IAAUA,IAAAA,QAAV,KAAA,KAAA,CAAUA,GAAV,KAAA,CAAUA,GAAAA,QAAQ,CAAlB,QAAA,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAmCD,KAAK,CAAxC,KAAA,CAAA,EAAA,EAAA,EAAA;AAAgDD,QAAAA,IAAI,EAAJA;AAAhD,OAAA,CAAA,CAARD;AAEA,UAAA,KAAA,EACIF,QAAQ,CAARA,KAAQ,CAARA;AACP;AAPLC,GAAAA;;AAUA,SAAA,KAAA;AAjBJ,CAAA;;AAoBO,IAAMK,UAAU,GAAG,SAAA,UAAA,CAAA,QAAA,EAAA,MAAA,EAAsB;AAC5C,MAAA,UAAA;AAEA,MAAMJ,KAAK,GAAGH,iBAAiB,CAAA,QAAA,EAAA,MAAA,EAG3B,UAAA,eAAA,EAAqB;AAAEO,IAAAA,UAAU,GAAGC,eAAe,CAAfA,KAAAA,CAAbD,OAAAA;AAH3B,GAA+B,CAA/B;AAMA,SAAOJ,KAAK,GAAA,UAAA,GAAZ,KAAA;AATG,CAAA;;;;AAYA,IAAMM,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAA,QAAA,EAAA,MAAA,EAAsB;AACrD,MAAA,OAAA;AAEA,MAAMN,KAAK,GAAGH,iBAAiB,CAAA,QAAA,EAAA,MAAA,EAG3B,UAAA,eAAA,EAAqB;AAAEU,IAAAA,OAAO,GAAPA,eAAAA;AAH3B,GAA+B,CAA/B;AAMA,SAAOP,KAAK,GAAA,aACN,MAAA,CAAA,SAAA,CAAA,CAAA,YAAA,CAAA,OAAA,EAA4B;AAAEG,IAAAA,QAAQ,EAAV,QAAA;AAAYK,IAAAA,aAAa,EAAER;AAA3B,GAA5B,CADM,GAAZ,IAAA;AATG,CAAA","sourcesContent":["import React from 'react';\nimport { matchPath } from 'react-router';\n\nexport const isRoutesDifferent = (current, next) => next.location?.pathname !== current.location?.pathname;\n\nconst findMatchingRoute = (location, routes, callback = (matchingElement) => { }) => {\n    let match;\n\n    // We use React.Children.forEach instead of React.Children.toArray().find()\n    // here because toArray adds keys to all child elements and we do not want\n    // to trigger an unmount/remount for two <Route>s that render the same\n    // component at different URLs.\n    React.Children.forEach(routes, child => {\n        if (match == null && React.isValidElement(child)) {\n            const path = child.props.path || child.props.from;\n            match = matchPath(location?.pathname, { ...child.props, path });\n\n            if (match)\n                callback(child);\n        }\n    });\n\n    return match;\n};\n\nexport const isLoadable = (location, routes) => {\n    let isLoadable;\n\n    const match = findMatchingRoute(\n        location,\n        routes,\n        (matchingElement) => { isLoadable = matchingElement.props.loading; }\n    );\n\n    return match ? isLoadable : false;\n};\n\nexport const findMatchingElement = (location, routes) => {\n    let element;\n\n    const match = findMatchingRoute(\n        location,\n        routes,\n        (matchingElement) => { element = matchingElement; }\n    );\n\n    return match\n        ? React.cloneElement(element, { location, computedMatch: match })\n        : null;\n};\n"]},"metadata":{},"sourceType":"script"}